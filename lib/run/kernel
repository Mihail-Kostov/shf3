
function run/mail() {
  local _sub="${1:-${FUNCNAME}}"
  local _sch="${2}"
  local _msg=""

  if test -z "${_sub}" || 
     test -z "${QMAILTO}" ; then
    return ${_false_}
  fi

  if ! test -z "${_sch}" ; then
    import que/${_sch}
    _sub="$(que/mail/sub) ${_sub}"
    _msg=$(que/mail/msg)
  fi

  # send mail
  import net/mail
  net/mail "${QMAILTO}" "${_sub}" "${_msg}"
}


function run/clean() {
  import gui
  import sys/dir
  import sys/lnk

  local _dirs="${*}"
  if test -z "${_dirs}" ; then
    return ${_false_}
  fi

  # header
  gui/line
  msg "${FUNCNAME}: $(date)"

  if test -z "${INPUTDIR}" || \
   ! test -d "${INPUTDIR}" ; then
    msg "Not found: ${INPUTDIR}"
    return ${_false_}
  fi

  # enter input dir
  local _idir="${INPUTDIR}"
  sys/dir/svwd "${_idir}"

  # clean dirs
  local dir
  local _dir
  local _pwd=$(pwd)
  for dir in ${_dirs} ; do
    _dir=$(ns/op/name "${!dir}" "+")
    _dir=$(cd "${_dir}";pwd)
    if test "${_pwd}" = "${_dir}" ; then
      continue
    fi
    if test -d "${_dir}" ; then
      msg "Clean : ${_dir}"
      sys/dir/rm "${_dir}"
    fi
  done
}


function help/run/prg() {
  cat << EOF
Program run wrapper

\$1 string  - mode
\$2 integer - check level
\$3 string  - program
\$4 string  - guide file
\$5 string  - scheduler

mode:
 B - batch
 I - interacitve
EOF
}

function run/prg() {
  import sys/dir
  import sys/lnk
  import run/chk
  import gui

  local _mode=${1:-B}
  local _chk=${2:-0}
  local _prg=${3}
  local _guide=${4}
  local _sch=${5}

  ### check
  run/chk ${_chk} "${_prg}" "${_guide}"
  if test $? -gt 0 ; then
    return ${_false_}
  fi

  # read guide
  source "${_guide}"

  ### import
  # program
  import run/${_prg}
  if test $? -gt 0 ; then
    msg "Program module run/${_prg} not found"
    return ${_false_}
  fi

  # scheduler
  if ! test -z "${_sch}" ; then
    import que/${_sch}
    if test $? -gt 0 ; then
      msg "Scheduler module que/${_sch} not found"
      return ${_false_}
    fi
  fi


  ### begin run

  # enter inputdir
  local _idir=$(ns/op/name "${INPUTDIR}" "+")
  sys/dir/svwd "${_idir}"
  msg "Input     : ${_idir}"

  # create workdir
  local _wdir=$(ns/op/name "${WORKDIR}" "+")
  if ! $(sys/dir/mk "${_wdir}") ; then
    return ${_false_}
  fi
  msg "Work      : ${_wdir}"

  # create resultdir
  local _rdir=$(ns/op/name "${RESULTDIR}" "+")
  if ! $(sys/dir/mk "${_rdir}") ; then
    run/clean WORKDIR
    return ${_false_}
  fi
  msg "Result    : ${_rdir}"


  ### broadcast

  # create stagedir for broadcast
  if $(ns/isop "${WORKDIR}" "+") ; then
    local _sdir="${run_stage_dir}/stage-${_prg}-${USER}-$$"
    if ! test -z "${STAGEDIR}" ; then
      _sdir="${STAGEDIR}"
    else
      STAGEDIR="${_sdir}"
    fi
    if ! $(sys/dir/mk "${_sdir}") ; then
      run/clean WORKDIR RESULTDIR
      return ${_false_}
    fi
    msg "Broadcast : ${_sdir}"
  fi

  # workdir link
  WORKDIRLINK="${_idir}/${_prg}-${$}"
  if ! $(ns/isop "${WORKDIR}" "+") ; then
    sys/lnk/mk "${_wdir}" "${WORKDIRLINK}"
  fi

  ### program init
  echo ""
  if test "${_mode}" = "I" ; then
    answer "run/${_prg}/init?"
    if test $? -gt 0 ; then
      return ${_false_}
    fi
  fi

  run/${_prg}/init
  if test $? -gt 0 ; then
    if test "${ONERR}" = "clean" ; then
      run/clean WORKDIR STAGEDIR RESULTDIR
      sys/lnk/rm "${WORKDIRLINK}"
    fi
    return ${_false_}
  fi

  # delete stage dir
  if $(ns/isop "${WORKDIR}" "+") ; then
    sys/dir/rm "${_sdir}"
  fi

  ### program run

  sys/dir/svwd "${_wdir}"

  # list inputs
  echo ""
  msg "Inputs in ${_wdir}"
  gui/line
  ls -lR
  gui/line

  # MPI & options
  local _out=${_prg}.output
  local _cmd="${PRGBIN}"

  if ! test -z "${PRERUN}" ; then
    _cmd="${PRERUN} ${_cmd}"
  fi

  if ! test -z "${PRGOPT}" ; then
    _cmd="${_cmd} ${PRGOPT}"
  fi

  echo ""
  msg "Command: ${_cmd}"

  ### lib override
  # Format: colon separated list
  if ! test -z "${LDLIB}" ; then
    if test -z "${LD_LIBRARY_PATH}" ; then
      export LD_LIBRARY_PATH="${LDLIB}"
    else
      export LD_LIBRARY_PATH="${LDLIB}:${LD_LIBRARY_PATH}"
    fi
    msg "LD_LIBRARY_PATH: ${LDLIB}"
  fi

  ### preload override
  # Format: space separated list
  if ! test -z "${LDPRE}" ; then
    if test -z "${LD_PRELOAD}" ; then
      export LD_PRELOAD="${LDPRE}"
    else
      export LD_PRELOAD="${LDPRE} ${LD_PRELOAD}"
    fi
    msg "LD_PRELOAD: ${LDPRE}"
  fi


  # interactive
  if test "${_mode}" = "I" ; then
    answer "Run command?"
    if test $? -gt 0 ; then
      return ${_false_}
    fi
  fi

  # mail program start
  run/mail "Program ${_prg} started"

  local _inp=$(ns/op/name "${MAININPUT}")
  if $(ns/isop "${MAININPUT}" "<") ; then
    ${_cmd} < "${_inp}" &> "${_out}"
  elif $(ns/isop "${MAININPUT}" "-") ; then
    ${_cmd} &> "${_out}"
  else
    ${_cmd} "${_inp}" &> "${_out}"
  fi
  _ret=$?

  # work dir  save mode
  local _oemsg="error cleaned / success saved"
  case "${ONERR}" in 
    "clean") _oemsg="error cleaned / success saved";;
    "save")  _oemsg="error saved   / success saved";;
  esac
  msg "Work directory in ${_oemsg}"

  # list output
  echo ""
  msg "Outputs in ${_wdir}"
  gui/line
  ls -lR
  gui/line

  # exit status
  if test ${_ret} -gt 0 && \
     test "${ONERR}" = "clean" ; then
    run/clean WORKDIR STAGEDIR RESULTDIR
    sys/lnk/rm "${WORKDIRLINK}"

    local _emsg="Program failed (exit code ${_ret})"
    msg "${_emsg}"
    run/mail "${_emsg}"
    return ${_ret}
  fi


  ### finish

  # interactive
  if test "${_mode}" = "I" ; then
    answer "run/${_prg}/finish?"
    if test $? -gt 0 ; then
      return ${_false_}
    fi
  fi

  run/${_prg}/finish
  _ret=$?
  if test ${_ret} -gt 0 && \
     test "${ONERR}" = "clean" ; then
    run/clean WORKDIR STAGEDIR RESULTDIR
    sys/lnk/rm "${WORKDIRLINK}"

    local _emsg="run/${_prg}/finish failed (exit code ${_ret})"
    msg "${_emsg}"
    run/mail "${_emsg}"
    return ${_ret}
  fi


  ### save

  # list output
  echo ""
  msg "Saved outputs in ${_wdir}"
  gui/line
  ls -lR ${RESULTS}
  gui/line

  if test "${ONERR}" != "leave" ; then
    run/${_prg}/save
    _ret=$?
    if test ${_ret} -gt 0 ; then
      if test "${ONERR}" = "clean" ; then
        run/clean
      fi
      local _emsg="run/${_prg}/save Failed (exit  code ${_ret})"
      msg "${_emsg}"
      run/mail "${_emsg}"
      return ${_ret}
    fi
    run/clean
  fi

  local _emsg="Program ${_prg} complete"
  msg "${_emsg}"
  run/mail "${_emsg}"
}


function run/sum() {
  # options
  local _prg=${1}
  local _guide=${2}

  # read guide
  if ! test -r "${_guide}" ; then
    sp_f_err_fnf "${_guide}"
    return ${_FALSE_}
  fi
  source "${_guide}"

  import run/${_prg}
  run/${_prg}/sum
}


