
function help/que/sub() {
  cat << EOF
\$1 string  - mode
\$2 string  - job file
\$3 logical - check
EOF
}

function que/sub() {
  import gui
  import que

  local _sub=${1:-B}
  local _job=${2:-${gbn}.job}
  local _chk=${3:-false}

  msg "Job file  : ${_job}"
  ### job file
  if ! test -r "${_job}" ; then
    msg "Job file not found"
    return ${_false_}
  fi
  source ${_job}
  msg/debug "Job file imported"

  # basic checks
  local i
  for i in NAME MODE QUEUE RUN ; do
    if test -z "${!i}" ; then
      msg "${i} not set"
      return ${_false_}
    fi
  done

  ### summary
  if test "${_sub}" = "C" ; then
    que/chk "${RUN}" "${_sub}"
    return $?
  fi

  ### queue file
  local _que="${que_dir}/${QUEUE:-default}"
  if ! test -r "${_que}" ; then
    msg "Queue file not found"
    return ${_false_}
  fi
  source "${_que}"
  msg/debug "Queue file imported"

  for i in QSCHED ; do
    if test -z "${!i}" ; then
      msg "${i} not set"
      return ${_false_}
    fi
  done

  ### import scheduler
  local _sch=${QSCHED}
  import que/${_sch}
  msg/debug "Scheduler ${_sch} imported"

  # scheduler batch file
  local _bat="./${_sch}.batch.sh"
  if test "${_sub}" = "L" ; then
    _bat="./${_sch}.login.sh"
  fi

  ### write batch file
  echo "#!${que_shell}"      > "${_bat}"
  echo "### Date $(date)"   >> "${_bat}"

  ### resource parameters
  if test "${MODE}" = "omp" ; then
    if test ${NODES} -gt 1 ; then
      msg "For OMP mode set NODES=1"
      return ${_false_}
    fi
  fi
  # nodes
  local _nodes=${NODES:-1}
  # sockets per node
  local _sckts=${SCKTS:-1}
  # cores per sockets
  local _cores=${CORES:-2}
  # slots per node (forced)
  local _sltpn=${SLTPN:-0}
  # threads per core (forced)
  local _thrds=${THRDS:-0}

  ### compound resource parameters
  # forced slots
  local __slots=$((_nodes*_sltpn))
  # total sockets
  local _sockets=$((_nodes*_sckts))
  # tasks per node
  local _tasks=$((_sckts*_cores))
  # total slots
  local _slots=$((_nodes*_tasks))
  # threads
  local _threads=${_tasks}

  # global resources for SGE
  SLOTS=${_slots}
  # over subscribe for SGE
  if test ${__slots} -gt 0 ; then
    SLOTS=${__slots}
  fi
  TASKS=${_tasks}

  ### scheduler setup
  echo "### Scheduler: ${_sch}" >> "${_bat}"
  que/${_sch} "${_sub}" "${_bat}"
  if test $? -gt 0 ; then
    return ${_false_}
  fi
  msg "Scheduler : ${_sch}"

  ### login
  if test "${_sub}" = "L" ; then
    echo ""
    answer "Show batch file?"
    if test $? -eq 0 ; then
      gui/line
      cat "${_bat}"
      gui/line
    fi

    # login
    echo ""
    answer "Queue login?"
    if test $? -gt 0 ; then
      return ${_false_}
    fi
    sh "${_bat}"
    return $?
  fi

  ### batch
  # queue setup
  if ! test -z "${QSETUP}" ; then
    echo "### Queue Setup"     >> "${_bat}"
    local _s
    for _s in ${QSETUP} ; do
      echo "source ${_s}"      >> "${_bat}"
    done
  fi

  # ulimit
  if ! test -z "${QULIMIT}" ; then
    echo "${QULIMIT}"          >> "${_bat}"
  fi

  # mail
  if test "${QMAIL}" = "runprg" ; then
    echo "### Mail Setup"            >> "${_bat}"
    echo "export QMAILTO=${QMAILTO}" >> "${_bat}"
    echo "Internal mail notifications"
  fi

  # job setup
  if ! test -z "${SETUP}" ; then
    echo "### Job Setup"       >> "${_bat}"
    local _s
    for _s in ${SETUP} ; do
      echo "source ${_s}"      >> "${_bat}"
    done
  fi

  # modules
  if ! test -z "${MODULE}" ; then
    echo "### Modules"         >> "${_bat}"
    local _m
    for _m in ${MODULE} ; do
      echo "module load ${_m}" >> "${_bat}"
    done
  fi

  if ! test -z "${MPI}" ; then
    msg "Parallel  : ${MODE}/${MPI}"
  else
    msg "Parallel  : ${MODE}"
  fi

  local _v=${VERBOSE:-0}

  ### begin MPIOMP
  if test "${MODE}" = "mpi" || \
     test "${MODE}" = "mpiomp" ; then

    echo "### MPI Setup" >> "${_bat}"

    ### basic checks
    # SGI MPT Machines
    if test -z "${MPI}" ; then
      msg "Set MPI type"
      return ${_false_}
    fi
    # setup scripts has to do it
    # if test "${MPI}" = "mpt" ; then
    #   if test -z "${MACHINES}" ; then
    #     msg "Set MACHINES for SGI MPT"
    #     return ${_false_}
    #   fi
    # fi

    # binding
    local _bind=""
    if ! test -z "${BIND}" ; then
      _bind="${BIND}"
      msg "Binding   : ${_bind}"
    fi

    # SGI MPT Perfboost
    local _boost=""
    if ! test -z "${BOOST}" ; then
      _boost="${BOOST}"
      msg "Perfboost : ${_boost}"
    fi

    # Profiler
    local _prof=""
    if ! test -z "${PROF}" ; then
      _prof="${PROF}"
      msg "Profiler  : ${_prof}"
    fi

    # default for MPIOMP
    local _np=${_socktes}
    local _pn=${_sckts}

    ### begin MPI OMP hybrid
    if test "${MODE}" = "mpi" ; then
      _np=${_slots}
      _pn=${_tasks}
      _threads=1
    else
      _threads=${_cores}
    fi

    ### MPI OMP
    case ${MPI} in
      ompi)
        # Open MPI
        echo "export MPI_OPT=\"-np ${_np} -npernode ${_pn} ${_bind} ${_prof}\""   >> "${_bat}"
        ;;
      impi)
        # Intel MPI
        echo "export MPI_OPT=\"-np ${_np} -perhost ${_pn} ${_bind} ${_prof}\""    >> "${_bat}"
        ;;
      mpt)
        # SGI MPT
        echo "export MPI_OPT=\"\${MACHINES} ${_pn} ${_bind} ${_boost} ${_prof}\"" >> "${_bat}"
        ;;
      *)
        msg "MPI: ${MPI} not implemented"
        return ${_false_}
        ;;
    esac
  fi
  ### end MPIOMP

  ### threads
  # forced by THRDS
  if test ${_thrds} -gt 0 ; then
    _threads=${_thrds}
  fi

  ### begin verbose
  if test ${_v} -gt 0 ; then
    case ${MPI} in
      ompi)
        # Open MPI
        MPI_OPT="-v ${MPI_OPT}"
        if test ${_v} -gt 1 ; then
          MPI_OPT="-report-bindings ${MPI_OPT}" >> "${_bat}"
        fi
        if test ${_v} -gt 2 ; then
          MPI_OPT="-d ${_v} ${MPI_OPT}"         >> "${_bat}"
        fi
        ;;
      impi)
        # Intel MPI
        echo "export I_MPI_DEBUG=${_v}"         >> "${_bat}"
        ;;
      mpt)
        echo "export MPI_VERBOSE=1"             >> "${_bat}"
        echo "export MPI_DSM_VERBOSE=1"         >> "${_bat}"
        echo "export MPI_DISPLAY_SETTINGS=1"    >> "${_bat}"
        if test ${_v} -gt 1 ; then
          echo "export MPI_VERBOSE2=1"          >> "${_bat}"
          echo "export MPI_IB_VERBOSE=1"        >> "${_bat}"
          echo "export MPI_SHARED_VERBOSE=1"    >> "${_bat}"
          echo "export MPI_XPMEM_VERBOSE=1"     >> "${_bat}"
        fi
        if test ${_v} -gt 2 ; then
          echo "export MPI_IB_VERBOSE3=1"       >> "${_bat}"
          echo "export MPI_COLL_OPT_VERBOSE=1"  >> "${_bat}"
          echo "export MPI_STATS=1"             >> "${_bat}"
        fi
        ;;
      *)
        msg "MPI: ${MPI} not implemented"
        return ${_false_}
        ;;
    esac
  fi
  
  ### end verbose

  ### Toggle Options
  if ! test -z "${TOGGLE}" ; then
    echo "### Options"                      >> "${_bat}"
    for i in ${TOGGLE} ; do
      echo "export ${i}=1"                  >> "${_bat}"
    done
  fi

  ### OMP
  echo "### OMP Setup"                      >> "${_bat}"
  echo "export OMP_NUM_THREADS=${_threads}" >> "${_bat}"
  echo "export MKL_NUM_THREADS=${_threads}" >> "${_bat}"
  if test ${_threads} -gt 1 ; then
    echo "export KMP_LIBRARY=turaround"     >> "${_bat}"
    if ! test -z "${KMPAFF}" ; then
      echo "export KMP_AFFINITY=${KMPAFF}"  >> "${_bat}"
    fi
  else
    echo "export KMP_LIBRARY=serial"        >> "${_bat}"
  fi
  # echo "export MKL_DYNAMIC=FALSE"         >> "${_bat}"

  ### setup mail
  echo "### Command" >> "${_bat}"
  if test "${RUN/*runprg*/runprg}" = "runprg" ; then
    # set scheduler
    RUN="${RUN} -s ${QSCHED}"

    # check
    if ${_chk} ; then
      que/chk "${RUN}"
      if test $? -gt 0 ; then
        msg "Job check failed"
        return ${_false_}
      fi
    fi
  fi
  echo "${RUN}"      >> "${_bat}"

  ### submit
  echo ""
  answer "Show batch file?"
  if test $? -eq 0 ; then
    gui/line
    cat "${_bat}"
    gui/line
  fi

  local _sub="que_${_sch}_qsub"
  _sub=${!_sub}
  if ! $(installed "${_sub}") ; then
    msg "${_sub} not found"
    return ${_false_}
  fi
  # submit
  answer "Submit job?"
  if test $? -gt 0 ; then
    return ${_false_}
  fi
  ${_sub} "${_bat}"
}


function help/que/chk() {
  cat << EOF
\$1 string - command
\$2 string - mode
EOF
}
function que/chk() {
  local _cmd="${1##runprg}"
  local _sub="${2:-B}"
  local _prg=""
  local _guide=""
  local _sch=""

  # reprocess args
  OPTIND=1
  local _o
  while getopts p:g:s: _opt ${_cmd[@]}; do
    case ${_opt} in
      p) _prg=${OPTARG};;
      g) _guide=${OPTARG};;
      s) _sch=${OPTARG};;
    esac
  done

  if test -z "${_prg}" ; then
    msg "Program module not set"
    return ${_false_}
  fi
  if test -z "${_guide}" || ! test -r "${_guide}" ; then
    msg "Guide not found"
    return ${_false_}
  fi

  import run
  # summary
  if test "${_sub}" = "S" ; then
    run/sum "${_prg}" "${_guide}"
    return $?
  fi
  # check
  run/chk "${_prg}" "${_guide}"
}
