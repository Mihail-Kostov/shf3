###
#
# SHF3 Kernel
#
###

### globals - redefined
gkn="kernel"
gcn="config"

# initial include path
gip="$(dirname ${BASH_SOURCE})"
grd=$(cd "${gip}/..";pwd)
gip=":${grd}/lib:"

# loaded modules
gim=""

# return values
_true_=0
_false_=1
_abort_=255

# error handling
failure="return ${_false_}"
success="return ${_true_}"

function failed() {
  local _r=${1:-${_false_}}
  if test ${_r} -gt 0 ; then
    $success
  fi
  $failure
}

function succeed() {
  local _r=${1:-${_false_}}
  if test ${_r} -eq 0 ; then
    $success
  fi
  $failure
}

function empty() {
  local _s="${1}"
  if test -z "${_s}" ; then
    $success
  fi
  $failure
}

function readable() {
  local _f="${1}"
  if test -r "${_f}" ; then
    $success
  fi
  $failure
}

# return false
# if failed $?;then $failure;fi
# return true
# if succeed $?;then $success;fi


### messages
function msg() {
  echo -e "[${gbn}] ${*}"
}

function msg/debug() {
  if ${gdbg} ; then
    msg "DEBUG: ${*}"
  fi
}

function msg/error() {
  msg "ERROR: ${*}"
  exit ${2:-${_false_}}
}

function msg/warn() {
  msg "WARN: ${*}"
}


### namespaces
function ns/dir() {
  echo "$(dirname ${1:-${BASH_SOURCE}})"
}

function ns/path() {
  echo $(cd $(dirname $1); pwd)/$(basename $1)
}

function ns/readlink() {
  echo $(cd -P "${1}"; pwd)
}

function ns/isfunc() {
  local _f="${1:-${FUNCNAME}}"
  if test $(type -t "${_f}") = "function" ; then
    $success
  fi
  $failure
}

function ns/func() {
  local _f=${1:-${FUNCNAME}}
  echo ${_f##*/}
}

function ns/var() {
  local _f=${1:-${FUNCNAME}}
  echo "${_f}" | sed s/\\//_/g
}

function ns/var/io() {
  local _c="${1}"
  local _i="${2}"
  local _o="${3}"
  if empty "${_c}"; then $failure; fi

  if ! empty "${_i}" ; then
    _c=$(echo "${_c}" | sed s/\<INPUT\>/"${_i}"/)
  fi
  if ! empty "${_o}" ; then
    _c=$(echo "${_c}" | sed s/\<OUTPUT\>/"${_o}"/)
  fi
  echo "${_c}"
}

function ns/var/cmd() {
  local _f="${1}"
  local _i="${2}"
  local _o="${3}"
  if empty "${_f}"; then $failure; fi
  
  local _c=$(ns/var "${_f}")
  _c=${!_c}
  _c=$(ns/var/io "${_c}" "${_i}" "${_o}")

  if empty "${_c}"; then $failure; fi

  ${_c}
}

function ns/func/dir() {
  local _f="${1:-${BASH_SOURCE}}"
  local i
  _IFS="${IFS}"
  IFS=$'\n'
  for i in $(cat "${_f}" | egrep "^function") ; do
    i=$(field "${i}" 2 " ")
    i=${i%%()}
    if test "${i}" = "${i/help/}" ; then
      echo "  ${i}"
    fi
  done
  IFS="${_IFS}"
}

# operators
function ns/op() {
  local _s="${1}"
  local _m="${2}"
  if empty "${_m}" ; then
    _m="< + -"
  fi

  local o
  for o in ${_m} ; do
    if test "${_s:0:1}" = "${o}" ; then
      $success
    fi
  done
  $failure
}

function ns/op/value() {
  local _s="${1}"
  local _m="${2}"
  if empty "${_m}" ; then
    _m="< + -"
  fi

  local o
  for o in ${_m} ; do
    if $(ns/op "${_s}" "${o}") ; then
      echo "${_s:1}"
    fi
  done
  echo "${_s}"
}

# path
function ns/inpath() {
  local _m="${1}"
  local _p="${2:-${gip}}"
  if empty "${_p}" || \
     empty "${_m}" ; then
    $failure
  fi
  if test "${_p}" = "${_p/:${_m}:/}" ; then
    $failure
  fi
  $success
}

function ns/lspath() {
  local _p="${1}"
  if empty "${_p}"; then $failure; fi

  echo "${_p}" | \
  awk '{split($0,a,":"); for(i in a) print a[i]}'
}

# associative arrays
function ns/aa() {
  local _aa=${1:-'{one:1,two:2,three:3}'}
  local _key=${2:-one}
  local _oby=${3:-1}
  local _ie=${4:-0}

  echo ${_aa} | awk -v key=${_key} -v oby=${_oby} -v ie=${_ie} \
  '{
    sub(/^[[:space:]]*{[[:space:]]*/,"")
    sub(/[[:space:]]*}[[:space:]]*/,"")
    split($0,va,"[[:space:]]*,[[:space:]]*")
    # print "->" $0 "<-"
    for( k in va ) {
      sub(/^[[:space:]]*/,"",va[v])
      sub(/[[:space:]]*$/,"",va[v])
      split(va[k],vva,"[[:space:]]*:[[:space:]]*")
      sub(/^'\''/,"",vva[1])
      sub(/'\''$/,"",vva[1])
      if(oby==1)
        aa[vva[1]]=vva[2]
      else
        aa[vva[2]]=vva[1]
    }
    # check key
    if(aa[key]=="") {
      print ie
      exit 1
    }
    print aa[key]
  }'
}

function ns/ext() {
  local _n="${1}"
  if empty "${_n}"; then $failure; fi

  local _bn=${_n%.*}
  echo =${_n##${_bn}}
}

### include
function include() {
  local _p="${1}"
  if empty "${_p}" ; then $failure; fi

  local __p=$(ns/op/value "${_p}" "+")
  msg/debug "${FUNCNAME} ${__p}"

  if ! test -d "${__p}" ; then
    $failure
  fi

  if test -z "${gip}" ; then
    gip=":${__p}:"
    $success
  fi

  if ! $(ns/inpath "${__p}" "${gip}") ; then
    if $(ns/op "${_p}" "+") ; then
      gip="${__p}${gip}:"
    else
      gip=":${gip}${__p}"
    fi
  fi
  $success
}

### import
function import/path() {
  local _m="${1}"
  if empty "${_m}" ; then
    echo ""
  fi
  local _kn="${_m}/${gkn}"
  if ! empty "${gip}" ; then
    _IFS=${IFS}
    IFS=:
    local i
    for i in ${gip}; do
      local _p="${i}"
      if test -z "${_p}" ; then
        continue
      fi
      if test -r "${_p}/${_kn}" ; then
        echo "${_p}/${_m}"
      fi
    done
    IFS=${_IFS}
  fi
}

function import() {
  local _m="${1}"
  # not loaded
  local _nl=false

  if empty "${gip}" || \
     empty "${_m}" ; then
    $failure
  fi

  msg/debug "${FUNCNAME} gim    : ${gim}"
  msg/debug "${FUNCNAME} import : ${_m}"

  # force reloading
  local __m=$(ns/op/value "${_m}" "+")
  if $(ns/inpath "${__m}" "${gim}") ; then
    if ! $(ns/op "${_m}" "+") ; then
      $success
    fi
  else
    _nl=true
  fi

  msg/debug "${FUNCNAME} import : ${__m}"

  # search
  local __p=$(import/path "${__m}")
  if empty "${__p}" ; then
    $failure
  fi

  local _lib="${__p}/${gkn}"
  local _cfg="${__p}/${gcn}"

  # read config
  if readable "${_cfg}" ; then
    source "${_cfg}"
  fi

  # load OS specific library config
  local __cfg="${_cfg}.${OSTYPE}"
  if readable ${__cfg} ; then
    source "${__cfg}"
  fi

  # user specific library config
  __cfg="${_cfg}.${USER}"
  if readable ${__cfg} ; then
    source "${__cfg}"
  fi

  # read lib
  if ! readable "${_lib}" ; then
    $failure
  fi
  msg/debug "${FUNCNAME} source : ${_lib}"
  source "${_lib}"

  if ${_nl} ; then
    if empty "${gim}" ; then
      gim=":${__m}:"
    else
      gim="${gim}${__m}:"
    fi
  fi
}

### misc
function help/field() {
  cat << EOF
${FUNCNAME}:
\$1 string    - field string
\$2 integer   - filed id
\$3 character - separator
EOF
}
function field() {
  local _s="${1}"
  local _f=${2:-1}
  local _x="${3:-|}"
  echo "${_s}" | cut  -d "${_x}" -f ${_f}
}

function installed() {
  local _b="${1}"
  if empty "${_b}" ; then $failure; fi

  which "${_b}" &> /dev/null
  if succeed $?;then $success;fi
}

function answer() {
  import str
  local _m="${1:-Answer}"
  local _t=${2:-3}
  local _a

  while true ; do
    echo -en "[${gbn}] ${_m} (y/n/q) [${_t}]: "
    read _a
    _a=$(str/tolower ${_a})
    case "${_a}" in
      "y" | "case" | "yes" )
        return ${_true_}
      ;;
      "n" | "no" | "q"  )
        echo -e "[${gbn}] Abort\n"
        return ${_false_}
      ;;
      *)
        echo -e "[${gbn}] Invalid\n"
        _t=$((_t-1))
      ;;
    esac
    if test ${_t} -lt 1 ; then
      return ${_false_}
    fi
  done
}

function choose() {
  import str
  local _m="${1:-Answer}"
  local _n=${2:-3}
  local _t=${2:-3}
  local _a

  while true ; do
    echo -en "[${gbn}] ${_m} (1-${_n}/n/q) [${_t}]: "
    read _a
    _a=$(str/tolower ${_a})
    case "${_a}" in
      "y" | "case" | "yes" )
        return ${_true_}
      ;;
      "n" | "no" | "q"  )
        echo -e "[${gbn}] Abort\n"
        return ${_abort_}
      ;;
      *)
        if test ${_a} -le ${_n} && \
           test ${_a} -gt 0 ; then
          return ${_a}
        else
          echo -e "[${gbn}] Invalid\n"
          _t=$((_t-1))
        fi
      ;;
    esac
    if test ${_t} -lt 1 ; then
      return ${_abort_}
    fi
  done
}

function is_int() {
  return $(test "$@" -eq "$@" > /dev/null 2>&1);
}

function epoch() {
  local _d=${1:-0}
  if ! $(is_int "${_d}") ; then
    echo "${_d}"
    $success
  fi
  if test ${_d} -eq 0 ; then
    date +%s
  else
    date -r ${_d} +"%Y-%m-%d %H:%M:%S"
  fi
}

function elapsed() {
  local _t0=${1}
  local _t1=${2}
  local _dt=$((_t1-_t0))

  h=$(( _dt / 3600 ))
  m=$(( ( _dt / 60 ) % 60 ))
  s=$(( _dt % 60 ))
  printf "%02d:%02d:%02d" $h $m $s
}

function check() {
  msg "import path    = ${gip}"
  msg "loaded modules = ${gim}"
}


# TODO column print
### help system
function help/kernel() {
  local _l="${grd}/lib"
  msg "Kernel functions:"
  ns/func/dir "${_l}/${gkn}"
}

function help/modules() {
  import sys/dir
  local _l=""
  if ! test -z "${gip}" ; then
    echo
    local j
    for j in $(ns/lspath ${gip}); do
      _l="${j}"
      echo "Available modules in ${_l}:"
      for i in $(sys/dir/rls "${_l}") ; do
        i=${i##${_l}}
        if ! empty "${i}"; then
          echo "${i##/}"
        fi
      done
    done
  fi
}

function help() {
  import sys/dir
  local _h="${1:-}"
  echo
  msg "Shell Framework Help System"
  gui/line

  if ! empty "${_h}" ; then
    local _f="help/${_h}"
    if $(ns/isfunc "${_f}") ; then
      ${_f}
      return $?
    fi
    msg "Help not available for ${_h}"
    $failure
  fi

  msg "Available help:"
  local i
  for i in $(set | grep "^help/*\ *\(\)" | awk '{print $1}') ; do
    i=${i##help}
    if ! empty "${i}" ; then
      echo "${i##/}"
    fi
  done
}
