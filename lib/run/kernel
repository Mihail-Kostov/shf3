
function help/run/mail() {
  cat << EOF
Description:
Send mail

Parameters:
\$1 string - subject

Environment:
QMAILTO    - email
SCHEDULER  - scheduler
EOF
}

function run/mail() {
  local _sub="${1:-${FUNCNAME}}"
  local _msg=""

  # no subject or address
  if test -z "${_sub}" || 
     test -z "${QMAILTO}" ; then
    return ${_false_}
  fi

  # get subject & messgae from scheduler
  local _sch="${SCHEDULER}"
  if ! test -z "${_sch}" ; then
    import que/${_sch}
    if test $? -gt 0 ; then
      msg "Module que/${_sch} not found"
      return ${_false_}
    fi
    _sub="$(que/mail/sub) ${_sub}"
    _msg=$(que/mail/msg)
  fi

  # send mail
  import net/mail
  net/mail "${QMAILTO}" "${_sub}" "${_msg}"
}


function help/run/clean() {
  cat << EOF
Description:
Clean directories

Parameters:
\$* strings - directories
EOF
}

function run/clean() {
  import gui
  import sys/dir
  import sys/lnk

  local _dirs="${*}"
  if test -z "${_dirs}" ; then
    return ${_false_}
  fi

  echo ""
  if test -z "${INPUTDIR}" || \
   ! test -d "${INPUTDIR}" ; then
    msg "Not found: ${INPUTDIR}"
    return ${_false_}
  fi

  # enter input dir
  local _idir="${INPUTDIR}"
  sys/dir/svwd "${_idir}"

  # clean dirs
  local dir
  local _dir
  local _pwd=$(pwd)
  for dir in ${_dirs} ; do
    _dir=$(ns/op/name "${!dir}" "+")
    if test -d "${_dir}" ; then
      _dir=$(cd "${_dir}";pwd)

      # avoid delete of inputdir
      if test "${_pwd}" = "${_dir}" ; then
        continue
      fi
      msg "Clean : ${_dir}"
      sys/dir/rm "${_dir}"
    fi
  done
}


function help/run/prg() {
  cat << EOF
Program run wrapper

\$1 string  - mode
\$2 integer - check level
\$3 string  - program
\$4 string  - guide file
\$5 string  - scheduler

mode:
 B - batch
 I - interacitve
EOF
}

function run/prg() {
  import sys/dir
  import sys/lnk
  import run/chk
  import gui

  local _mode=${1:-B}
  local _chk=${2:-0}
  local _prg=${3}
  local _guide=${4}
  local _sch=${5}

  ### check
  run/chk ${_chk} "${_prg}" "${_guide}"
  if test $? -gt 0 ; then
    return ${_false_}
  fi

  # read guide
  source "${_guide}"


  ### import

  # program
  import run/prg/${_prg}
  if test $? -gt 0 ; then
    msg "Module not found: run/prg/${_prg}"
    return ${_false_}
  fi

  # set scheduler
  if ! test -z "${_sch}" ; then
    import que/${_sch}
    if test $? -gt 0 ; then
      msg "Module not found: que/${_sch}"
      return ${_false_}
    fi

    SCHEDULER=${_sch}

    # set broadcast
    local _bca="que_${_sch}_qbca"
    BROADCAST=${!_bca}
  fi


  ### begin run

  # enter inputdir
  local _idir=$(ns/op/name "${INPUTDIR}" "+")
  sys/dir/svwd "${_idir}"
  msg "Input  : ${_idir}"

  # create workdir
  if test -z "${WORKDIR}" ; then
    msg "Directory not found: \$WORKDIR"
    return ${_false_}
  fi
  local _wdir=$(ns/op/name "${WORKDIR}" "+")
  if ! $(sys/dir/mk "${_wdir}") ; then
    msg "Create directory failed: ${WORKDIR}"
    return ${_false_}
  fi
  msg "Work   : ${_wdir}"

  # create resultdir
  if test -z "${RESULTDIR}" ; then
    msg "Directory not found: \$RESULTDIR"
    run/clean WORKDIR
    return ${_false_}
  fi
  local _rdir=$(ns/op/name "${RESULTDIR}" "+")
  if ! $(sys/dir/mk "${_rdir}") ; then
    msg "Create directory failed: ${RESULTDIR}"
    run/clean WORKDIR
    return ${_false_}
  fi
  msg "Result : ${_rdir}"


  ### broadcast

  # create stagedir for broadcast
  if $(ns/isop "${WORKDIR}" "+") ; then
    local _sdir="${run_stage_dir}/stage-${_prg}-${USER}-$$"
    if ! test -z "${STAGEDIR}" ; then
      _sdir="${STAGEDIR}"
    else
      STAGEDIR="${_sdir}"
    fi
    if ! $(sys/dir/mk "${_sdir}") ; then
      run/clean WORKDIR RESULTDIR
      return ${_false_}
    fi
    msg "Stage  : ${_sdir}"
  fi

  # workdir link
  WORKDIRLINK="${_idir}/${_prg}-${$}"
  if ! $(ns/isop "${WORKDIR}" "+") ; then
    sys/lnk/mk "${_wdir}" "${WORKDIRLINK}"
  fi


  ### program init

  if test "${_mode}" = "I" ; then
    echo ""
    answer "run/prg/${_prg}/init?"
    if test $? -gt 0 ; then
      return ${_false_}
    fi
    echo ""
  fi

  # init inputs & data file
  run/prg/${_prg}/init
  if test $? -gt 0 ; then
    if test "${ONERR}" = "clean" ; then
      run/clean WORKDIR STAGEDIR RESULTDIR
      sys/lnk/rm "${WORKDIRLINK}"
    fi
    return ${_false_}
  fi

  # delete stage dir
  if $(ns/isop "${WORKDIR}" "+") ; then
    sys/dir/rm "${_sdir}"
    if test $? -gt 0 ; then
      msg "Stage clean failed"
    fi
  fi


  ### program run

  # enter work dir
  sys/dir/svwd "${_wdir}"

  # list inputs
  echo ""
  sys/dir/lsl . "Inputs in ${_wdir}"

  # MPI & options
  local _out=${_prg}.output
  local _cmd="${PRGBIN}"

  if ! test -z "${PRERUN}" ; then
    _cmd="${PRERUN} ${_cmd}"
  fi

  if ! test -z "${PRGOPT}" ; then
    _cmd="${_cmd} ${PRGOPT}"
  fi

  echo ""
  # lib override
  # Format: colon separated list
  if ! test -z "${LDLIB}" ; then
    if test -z "${LD_LIBRARY_PATH}" ; then
      export LD_LIBRARY_PATH="${LDLIB}"
    else
      export LD_LIBRARY_PATH="${LDLIB}:${LD_LIBRARY_PATH}"
    fi
    msg "LD_LIBRARY_PATH: ${LDLIB}"
  fi

  # preload override
  # Format: space separated list
  if ! test -z "${LDPRE}" ; then
    if test -z "${LD_PRELOAD}" ; then
      export LD_PRELOAD="${LDPRE}"
    else
      export LD_PRELOAD="${LDPRE} ${LD_PRELOAD}"
    fi
    msg "LD_PRELOAD: ${LDPRE}"
  fi

  if test "${_mode}" = "I" ; then
    answer "Run command?"
    if test $? -gt 0 ; then
      return ${_false_}
    fi
    echo ""
    echo ""
  fi

  # mail program start
  run/mail "Program ${_prg} started"
  msg "== Begin == $(date) =="
  msg "Program : ${_cmd}"
  msg "Input   : ${_inp}"
  msg "Output  : ${_out}"

  local _inp=$(ns/op/name "${MAININPUT}")

  # start timer
  local _t0=$(epoch)
  # start program
  if $(ns/isop "${MAININPUT}" "<") ; then
    ${_cmd} < "${_inp}" &> "${_out}"
  elif $(ns/isop "${MAININPUT}" "-") ; then
    ${_cmd} &> "${_out}"
  else
    ${_cmd} "${_inp}" &> "${_out}"
  fi
  _ret=$?
  # stop timer
  local _t1=$(epoch)
  msg "==  End  == $(date) =="

  msg "Elapsed : $((_t1-_t0)) s"

  # exit check
  if test ${_ret} -gt 0 ; then
    msg "Exit    : ${_ret}"
  else
    msg "Success"
  fi

  echo ""
  # work dir save mode
  if test -z "${ONERR}" ; then
    ONERR="clean"
  fi
  local _oemsg=""
  case "${ONERR}" in 
    "clean") _oemsg="error cleaned / success saved";;
    "save")  _oemsg="error saved   / success saved";;
  esac
  msg "Outputs in case of ${_oemsg}"

  # list output
  echo ""
  sys/dir/lsl . "Outputs in ${_wdir}"

  # exit status
  if test ${_ret} -gt 0 && \
     test "${ONERR}" = "clean" ; then
    run/clean WORKDIR STAGEDIR RESULTDIR
    sys/lnk/rm "${WORKDIRLINK}"

    local _emsg="Program failed (exit code ${_ret})"
    msg "${_emsg}"
    run/mail "${_emsg}"
    return ${_ret}
  fi


  ### finish

  if test "${_mode}" = "I" ; then
    echo ""
    answer "run/prg/${_prg}/finish?"
    if test $? -gt 0 ; then
      return ${_false_}
    fi
    echo ""
  fi

  run/prg/${_prg}/finish
  _ret=$?
  if test ${_ret} -gt 0 && \
     test "${ONERR}" = "clean" ; then
    run/clean WORKDIR STAGEDIR RESULTDIR
    sys/lnk/rm "${WORKDIRLINK}"

    local _emsg="run/prg/${_prg}/finish failed (exit code ${_ret})"
    msg "${_emsg}"
    run/mail "${_emsg}"
    return ${_ret}
  fi


  ### save

  # list output
  if test -z "${RESULT}" ; then
    RESULT="*"
  fi
  echo ""
  sys/dir/lsl "${RESULT}" "Saved outputs in ${_wdir}"

  if test "${ONERR}" != "leave" ; then
    run/prg/${_prg}/save
    _ret=$?
    if test ${_ret} -gt 0 ; then
      if test "${ONERR}" = "clean" ; then
        run/clean WORKDIR STAGEDIR RESULTDIR
        sys/lnk/rm "${WORKDIRLINK}"
      fi
      local _emsg="run/prg/${_prg}/save Failed (exit code ${_ret})"
      msg "${_emsg}"
      run/mail "${_emsg}"
      return ${_ret}
    fi
    run/clean WORKDIR STAGEDIR RESULTDIR
    sys/lnk/rm "${WORKDIRLINK}"
  fi

  local _emsg="Program ${_prg} complete"
  msg "${_emsg}"
  run/mail "${_emsg}"
}
