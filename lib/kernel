###
#
# SHF3 Kernel
#
###

### globals - redefined
gkn="kernel"
gcn="config"

# initial include path
gip="$(dirname ${BASH_SOURCE})"
grd=$(cd "${gip}/..";pwd)
gip=":${grd}/lib:"

# loaded modules
gim=""

# return values
_true_=0
_false_=1

### messages
function msg() {
  echo -e "[${gbn}] ${*}"
}

function msg/debug() {
  if ${gdbg} ; then
    msg "DEBUG: ${*}"
  fi
}

function msg/error() {
  msg "ERROR: ${*}"
  exit ${2:-${_false_}}
}

function msg/warn() {
  msg "WARN: ${*}"
}


### namespaces
function ns/dir() {
  echo "$(dirname ${1:-${BASH_SOURCE}})"
}

function ns/path() {
  echo $(cd $(dirname $1); pwd)/$(basename $1)
}

function ns/isfunc() {
  local _f="${1:-${FUNCNAME}}"
  if test $(type -t "${_f}") = "function" ; then
    return ${_true_}
  fi
  return ${_false_}
}

function ns/func() {
  local _f=${1:-${FUNCNAME}}
  echo ${_f##*/}
}

function ns/var() {
  local _f=${1:-${FUNCNAME}}
  echo "${_f}" | sed s/\\//_/g
}

function ns/var/io() {
  local _c="${1}"
  local _i="${2}"
  local _o="${3}"
  if test -z "${_c}" ; then
    return ${_false_}
  fi
  if ! test -z "${_i}" ; then
    _c=$(echo "${_c}" | sed s/\<INPUT\>/"${_i}"/)
  fi
  if ! test -z "${_o}" ; then
    _c=$(echo "${_c}" | sed s/\<OUTPUT\>/"${_o}"/)
  fi
  echo "${_c}"
}

function ns/var/cmd() {
  local _f="${1}"
  local _i="${2}"
  local _o="${3}"
  if test -z "${_f}" ; then
    return ${_false_}
  fi
  local _c=$(ns/var "${_f}")
  _c=${!_c}
  _c=$(ns/var/io "${_c}" "${_i}" "${_o}")
  if test -z "${_c}" ; then
    return ${_false_}
  fi
  ${_c}
}

function ns/func/dir() {
  local _f="${1:-${BASH_SOURCE}}"
  local i
  _IFS="${IFS}"
  IFS=$'\n'
  for i in $(cat "${_f}" | egrep "^function") ; do
    i=$(field "${i}" 2 " ")
    i=${i%%()}
    if test "${i}" = "${i/help/}" ; then
      echo "  ${i}"
    fi
  done
  IFS="${_IFS}"
}

# operators
function ns/isop() {
  local _s="${1}"
  local _m="${2}"
  if test -z "${_m}" ; then
    _m="< + -"
  fi

  local o
  for o in ${_m} ; do
    if test "${_s:0:1}" = "${_m}" ; then
      return ${_true_}
    fi
  done
  return ${_false_}
}

function ns/op/name() {
  local _s="${1}"
  local _m="${2}"
  if test -z "${_m}" ; then
    _m="< + -"
  fi

  local o
  for o in ${_m} ; do
    if $(ns/isop "${_s}" "${_m}") ; then
      echo "${_s:1}"
      return ${_true_}
    fi
  done
  echo "${_s}"
  return ${_false_}
}

# path
function ns/inpath() {
  local _m="${1}"
  local _p="${2:-${gip}}"
  if test -z "${_p}" || test -z "${_m}" ; then
    return ${_false_}
  fi
  if test "${_p}" = "${_p/:${_m}:/}" ; then
    return ${_false_}
  fi
  return ${_true_}
}

function ns/lspath() {
  local _p="${1}"
  if test -z "${_p}" ; then
    return ${_false_}
  fi
  echo "${_p}" | \
  awk '{split($0,a,":"); for(i in a) print a[i]}'
}

# associative arrays
function ns/aa() {
  local _aa=${1:-'{one:1,two:2,three:3}'}
  local _key=${2:-one}
  local _oby=${3:-1}
  local _ie=${4:-0}

  echo ${_aa} | awk -v key=${_key} -v oby=${_oby} -v ie=${_ie} \
  '{
    sub(/^[[:space:]]*{[[:space:]]*/,"")
    sub(/[[:space:]]*}[[:space:]]*/,"")
    split($0,va,"[[:space:]]*,[[:space:]]*")
    # print "->" $0 "<-"
    for( k in va ) {
      sub(/^[[:space:]]*/,"",va[v])
      sub(/[[:space:]]*$/,"",va[v])
      split(va[k],vva,"[[:space:]]*:[[:space:]]*")
      sub(/^'\''/,"",vva[1])
      sub(/'\''$/,"",vva[1])
      if(oby==1)
        aa[vva[1]]=vva[2]
      else
        aa[vva[2]]=vva[1]
    }
    # check key
    if(aa[key]=="") {
      print ie
      exit 1
    }
    print aa[key]
  }'
}

function ns/ext() {
  local _n="${1}"
  if test -z "${_n}" ; then
    return ${_false_}
  fi
  local _bn=${_n%.*}
  echo =${_n##${_bn}}
}

### include
function include() {
  local _p="${1}"
  if test -z "${_p}" ; then
    return ${_false_}
  fi

  local __p=$(ns/op/name "${_p}" "+")
  msg/debug "${FUNCNAME} ${__p}"

  if ! test -d "${__p}" ; then
    return ${_false_}
  fi

  if test -z "${gip}" ; then
    gip=":${__p}:"
    return ${_true_}
  fi

  if ! $(ns/inpath "${__p}" "${gip}") ; then
    if $(ns/isop "${_p}" "+") ; then
      gip="${__p}${gip}:"
    else
      gip=":${gip}${__p}"
    fi
  fi
  return ${_true_}
}

### import
function import/path() {
  local _m="${1}"
  if test -z "${_m}" ; then
    echo "${_m}"
  fi

  local _kn="${_m}/${gkn}"
  if ! test -z "${gip}" ; then
    _IFS=${IFS}
    IFS=:
    local i
    for i in ${gip}; do
      local _p="${i}"
      if test -r "${_p}/${_kn}" ; then
        echo "${_p}/${_m}"
      fi
    done
    IFS=${_IFS}
  else
    echo ""
  fi
}

function import() {
  local _m="${1}"
  # not loaded
  local _nl=false

  if test -z "${gip}" || test -z "${_m}" ; then
    return ${_false_}
  fi

  msg/debug "${FUNCNAME} gim    : ${gim}"
  msg/debug "${FUNCNAME} import : ${_m}"

  # force reloading
  local __m=$(ns/op/name "${_m}" "+")
  if $(ns/inpath "${__m}" "${gim}") ; then
    if ! $(ns/isop "${_m}" "+") ; then
      # skipped
      return ${_true_}
    fi
  else
    _nl=true
  fi

  msg/debug "${FUNCNAME} import : ${__m}"

  # search
  local __p=$(import/path "${__m}")
  if test -z "${__p}" ; then
    return ${_false_}
  fi

  local _lib="${__p}/${gkn}"
  local _cfg="${__p}/${gcn}"

  # read config
  if test -r "${_cfg}" ; then
    source "${_cfg}"
  fi

  # load OS specific library config
  local __cfg="${_cfg}.${OSTYPE}"
  if test -r ${__cfg} ; then
    source "${__cfg}"
  fi

  # user specific library config
  __cfg="${_cfg}.${USER}"
  if test -r ${__cfg} ; then
    source "${__cfg}"
  fi

  # read lib
  if test -r "${_lib}" ; then
    msg/debug "${FUNCNAME} source : ${_lib}"
    source "${_lib}"
  else
    return ${_false_}
  fi
  if ${_nl} ; then
    if test -z "${gim}" ; then
      gim=":${__m}:"
    else
      gim="${gim}${__m}:"
    fi
  fi
}

### misc
function field() {
  local _s="${1}"
  local _f=${2:-1}
  local _x="${3:-|}"
  echo "${_s}" | cut  -d "${_x}" -f ${_f}
}

function installed() {
  local _b="${1}"
  if test -z "${_b}" ; then
    return ${_false_}
  fi
  which "${_b}" &> /dev/null
  if test $? -eq 0; then
    return ${_true_}
  fi
  return ${_false_}
}

function answer() {
  import str
  local _m="${1:-Answer}"
  local _f=${2:-3}
  local _a

  while true ; do
    echo -en "[${gbn}] ${_m} (y/n/q) [${_f}]: "
    read _a
    _a=$(str/tolower ${_a})
    case "${_a}" in
      "y" | "case" | "yes" )
        return ${_true_}
      ;;
      "n" | "no" | "q"  )
        echo -e "[${gbn}] Abort\n"
        return ${_false_}
      ;;
      *)
        echo -e "[${gbn}] Invalid\n"
        _f=$((_f-1))
      ;;
    esac
    if test ${_f} -lt 1 ; then
      return ${_false_}
    fi
  done
}

function epoch() {
  local _d=${1:-0}
  if test ${_d} -eq 0 ; then
    date +%s
  else
    date -r ${_d} +"%Y-%m-%d %H:%M:%S"
  fi
}

function check() {
  msg "import path    = ${gip}"
  msg "loaded modules = ${gim}"
}


### help system
function help/kernel() {
  local _l="${grd}/lib"
  msg "Kernel functions:"
  ns/func/dir "${_l}/${gkn}"
}

function help/modules() {
  import sys/dir
  local _l=""
  if ! test -z "${gip}" ; then
    echo
    local j
    for j in $(ns/lspath ${gip}); do
      _l="${j}"
      echo "Available modules in ${_l}:"
      for i in $(sys/dir/rls "${_l}") ; do
        i=${i##${_l}}
        if ! test -z "${i}"; then
          echo "${i##/}"
        fi
      done
    done
  fi
}

function help() {
  import sys/dir
  local _h="${1:-}"
  echo
  msg "Shell Framework Help System"
  gui/line

  if ! test -z "${_h}" ; then
    local _f="help/${_h}"
    if $(ns/isfunc "${_f}") ; then
      ${_f}
      return $?
    fi
    msg "Help not available for ${_h}"
    return ${_false_}
  fi

  msg "Available help:"
  local i
  for i in $(set | grep "^help/*\ *\(\)" | awk '{print $1}') ; do
    i=${i##help}
    if ! test -z "${i}" ; then
      echo "${i##/}"
    fi
  done
}

### binary check
if $(installed pv) ; then
  gpv=true
else
  gpv=false
fi
